<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#FF4F38">
<meta name="mobile-web-app-capable" content="yes">
<title>Samantha â€¢ Streaming</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Helvetica Neue',sans-serif;background:#FF4F38;color:rgba(0,0,0,0.7);touch-action:manipulation}
body{padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}

#pin-screen,#boot-screen,#main-screen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center}
#pin-screen{z-index:30}
#boot-screen{z-index:20;opacity:0;pointer-events:none}
#main-screen{z-index:10;opacity:0;pointer-events:none}

.pin-dots{display:flex;gap:18px;margin-bottom:48px}
.pin-dot{width:16px;height:16px;border-radius:50%;border:2px solid rgba(0,0,0,0.5);transition:background .15s}
.pin-dot.filled{background:rgba(0,0,0,0.8);border-color:rgba(0,0,0,0.8)}
.keypad{display:grid;grid-template-columns:repeat(3,80px);gap:12px}
.key{width:80px;height:80px;border-radius:50%;border:1.5px solid rgba(0,0,0,0.35);background:transparent;color:rgba(0,0,0,0.8);font-size:28px;font-weight:300;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .1s,transform .1s;user-select:none}
.key:active{background:rgba(0,0,0,0.1);transform:scale(0.95)}
.key.zero{grid-column:2}
.key.del{border:none;font-size:16px;letter-spacing:1px}
.pin-error{color:rgba(0,0,0,0.6);font-size:13px;height:20px;margin-bottom:24px;letter-spacing:1px}

#boot-canvas{width:100%;height:100%}

#viz-canvas{position:absolute;inset:0;width:100%;height:100%}
#status{position:absolute;bottom:calc(60px + env(safe-area-inset-bottom));left:0;right:0;text-align:center;font-size:13px;letter-spacing:2px;text-transform:uppercase;opacity:0.5;transition:opacity .3s}
#transcript{position:absolute;bottom:calc(20px + env(safe-area-inset-bottom));left:20px;right:20px;text-align:center;font-size:13px;color:rgba(0,0,0,0.35);max-height:40px;overflow:hidden;line-height:1.5}
#response-text{position:absolute;left:24px;right:24px;top:50%;transform:translateY(40px);text-align:center;font-size:17px;font-weight:300;color:white;line-height:1.6;letter-spacing:0.3px;opacity:0;transition:opacity 0.8s ease,transform 0.8s ease;pointer-events:none}
#response-text.visible{opacity:1;transform:translateY(50px)}
#response-text.fade-out{opacity:0;transform:translateY(60px)}
#conn-dot{position:absolute;top:calc(12px + env(safe-area-inset-top));right:calc(12px + env(safe-area-inset-right));width:8px;height:8px;border-radius:50%;background:rgba(0,0,0,0.2);transition:background .3s}
#conn-dot.connected{background:#1a1a1a}

/* Streaming indicators */
#streaming-indicator{position:absolute;top:calc(12px + env(safe-area-inset-top));left:calc(12px + env(safe-area-inset-left));font-size:10px;color:rgba(0,0,0,0.6);opacity:0;transition:opacity .3s}
#streaming-indicator.active{opacity:1}

#latency-display{position:absolute;bottom:calc(100px + env(safe-area-inset-bottom));left:20px;font-size:11px;color:rgba(0,0,0,0.4);opacity:0;transition:opacity .3s}
#latency-display.visible{opacity:1}
</style>
</head>
<body>

<div id="pin-screen">
  <div class="pin-error" id="pin-error"></div>
  <div class="pin-dots" id="pin-dots">
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
  </div>
  <div class="keypad" id="keypad">
    <div class="key" data-n="1">1</div><div class="key" data-n="2">2</div><div class="key" data-n="3">3</div>
    <div class="key" data-n="4">4</div><div class="key" data-n="5">5</div><div class="key" data-n="6">6</div>
    <div class="key" data-n="7">7</div><div class="key" data-n="8">8</div><div class="key" data-n="9">9</div>
    <div class="key del" data-n="del">DEL</div><div class="key zero" data-n="0">0</div>
  </div>
</div>

<div id="boot-screen"><canvas id="boot-canvas"></canvas></div>

<div id="main-screen">
  <canvas id="viz-canvas"></canvas>
  <div id="conn-dot"></div>
  <div id="streaming-indicator">ðŸ”´ STREAMING</div>
  <div id="response-text"></div>
  <div id="status">tap to talk</div>
  <div id="transcript"></div>
  <div id="latency-display"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function(){
'use strict';

const PIN_CODE = '0913';
const BG = '#FF4F38';

// â”€â”€ Backend config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const IS_LOCAL = location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.port === '8765';
const IS_TAILSCALE = location.hostname.includes('tail');
const WS_URL = (IS_LOCAL || IS_TAILSCALE)
  ? `${location.protocol === 'https:' ? 'wss:' : 'ws:'}//${location.host}/ws`
  : 'wss://desktop-sv160n9.tail4e682f.ts.net:8765/ws';

let ws = null;
let wsReady = false;

// â”€â”€ PIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let pinEntry = '';
const dots = document.querySelectorAll('.pin-dot');
const pinError = document.getElementById('pin-error');
const ss = document.createElement('style');
ss.textContent = '@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-12px)}75%{transform:translateX(12px)}}';
document.head.appendChild(ss);

document.getElementById('keypad').addEventListener('click', e => {
  const k = e.target.closest('.key');
  if (!k) return;
  const n = k.dataset.n;
  if (n === 'del') { pinEntry = pinEntry.slice(0,-1); updateDots(); return; }
  if (pinEntry.length >= 4) return;
  pinEntry += n;
  updateDots();
  if (pinEntry.length === 4) {
    if (pinEntry === PIN_CODE) {
      setTimeout(startBoot, 200);
    } else {
      pinError.textContent = 'incorrect';
      document.getElementById('pin-dots').style.animation = 'shake .4s';
      setTimeout(() => { pinEntry = ''; updateDots(); pinError.textContent = ''; document.getElementById('pin-dots').style.animation = ''; }, 600);
    }
  }
});
function updateDots() { dots.forEach((d,i) => d.classList.toggle('filled', i < pinEntry.length)); }

// â”€â”€ BOOT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startBoot() {
  const pinEl = document.getElementById('pin-screen');
  pinEl.style.opacity = '0'; pinEl.style.transition = 'opacity .4s';
  setTimeout(() => pinEl.style.display = 'none', 400);

  const bootEl = document.getElementById('boot-screen');
  bootEl.style.opacity = '1'; bootEl.style.pointerEvents = 'auto';

  const canvas = document.getElementById('boot-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setClearColor(new THREE.Color(BG));
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 80;

  const pi2 = Math.PI * 2, length = 30, radius = 5.6;
  const curve = new THREE.Curve();
  curve.getPoint = function(p) {
    var x = length * Math.sin(pi2*p), y = radius * Math.cos(pi2*3*p), z, t;
    t = p%0.25/0.25; t = p%0.25 - (2*(1-t)*t*-0.0185 + t*t*0.25);
    if (Math.floor(p/0.25)==0 || Math.floor(p/0.25)==2) t *= -1;
    z = radius * Math.sin(pi2*2*(p-t));
    return new THREE.Vector3(x, y, z);
  };

  const geo = new THREE.TubeGeometry(curve, 200, 1.1, 2, true);
  const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  const mesh = new THREE.Mesh(geo, mat);
  const group = new THREE.Group();
  group.add(mesh); scene.add(group);

  let startTime = performance.now(), transitionStarted = false, bootDone = false;

  function animate() {
    const t = (performance.now() - startTime) / 1000;
    group.rotation.x = t * 0.2;
    group.rotation.y = t * 0.3;

    if (t > 1.5 && !transitionStarted) {
      transitionStarted = true;
      bootEl.style.transition = 'opacity .8s'; bootEl.style.opacity = '0';
      setTimeout(() => {
        bootEl.style.display = 'none';
        startMain();
      }, 800);
    }

    if (!bootDone) {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }
  }
  animate();

  function startMain() {
    bootDone = true;
    const mainEl = document.getElementById('main-screen');
    mainEl.style.opacity = '1'; mainEl.style.pointerEvents = 'auto';
    initMain();
  }
}

// â”€â”€ MAIN â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initMain() {
  const canvas = document.getElementById('viz-canvas');
  const ctx = canvas.getContext('2d');
  const mainEl = document.getElementById('main-screen');
  const statusEl = document.getElementById('status');
  const transcriptEl = document.getElementById('transcript');
  const connDot = document.getElementById('conn-dot');
  const streamingIndicator = document.getElementById('streaming-indicator');
  const latencyDisplay = document.getElementById('latency-display');

  let W, H, devicePixelRatio = Math.min(window.devicePixelRatio || 1, 2);

  // Request mic permission early (iOS requirement)
  navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
    stream.getTracks().forEach(t => t.stop());
    console.log('Mic permission granted');
  }).catch(e => console.warn('Mic permission denied', e));

  function resize() {
    W = canvas.width = window.innerWidth * devicePixelRatio;
    H = canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  resize();
  window.addEventListener('resize', resize);

  // State
  let state = 'idle';
  let amplitude = 0, targetAmplitude = 0, breathPhase = 0;
  let audioCtx, analyser, dataArray, micStream;
  let mediaRecorder, audioChunks = [];
  let playbackAnalyser, playbackDataArray;

  // â”€â”€ Streaming Audio Context â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let streamingAudioCtx = null;
  let audioQueue = [];
  let isPlaying = false;
  let nextStartTime = 0;

  async function initAudioContext() {
    if (!streamingAudioCtx) {
      streamingAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (streamingAudioCtx.state === 'suspended') {
      await streamingAudioCtx.resume();
    }
  }

  async function playAudioChunk(audioBytes) {
    await initAudioContext();
    
    try {
      const audioBuffer = await streamingAudioCtx.decodeAudioData(audioBytes.slice());
      const source = streamingAudioCtx.createBufferSource();
      source.buffer = audioBuffer;

      // Create analyser for visualization
      playbackAnalyser = streamingAudioCtx.createAnalyser();
      playbackAnalyser.fftSize = 256;
      playbackDataArray = new Uint8Array(playbackAnalyser.frequencyBinCount);

      source.connect(playbackAnalyser);
      playbackAnalyser.connect(streamingAudioCtx.destination);

      // Schedule seamless playback
      const currentTime = streamingAudioCtx.currentTime;
      const startTime = Math.max(currentTime, nextStartTime);
      source.start(startTime);
      nextStartTime = startTime + audioBuffer.duration;

      if (!isPlaying) {
        isPlaying = true;
        pollPlayback();
      }

      // Stop when done
      source.onended = () => {
        if (audioQueue.length === 0) {
          setTimeout(() => {
            if (audioQueue.length === 0) {
              isPlaying = false;
              targetAmplitude = 0;
              setState('idle');
              hideResponseText();
            }
          }, 100);
        }
      };

    } catch (error) {
      console.error('Audio playback error:', error);
    }
  }

  function pollPlayback() {
    if (!isPlaying) {
      targetAmplitude = 0;
      return;
    }
    requestAnimationFrame(pollPlayback);
    if (playbackAnalyser && playbackDataArray) {
      playbackAnalyser.getByteFrequencyData(playbackDataArray);
      let sum = 0;
      for (let i = 0; i < playbackDataArray.length; i++) sum += playbackDataArray[i];
      targetAmplitude = (sum / playbackDataArray.length) / 255;
    }
  }

  // â”€â”€ WebSocket â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function connectWS() {
    ws = new WebSocket(WS_URL);
    ws.onopen = () => { wsReady = true; connDot.classList.add('connected'); console.log('WS connected'); };
    ws.onclose = () => { wsReady = false; connDot.classList.remove('connected'); setTimeout(connectWS, 3000); };
    ws.onerror = () => { wsReady = false; connDot.classList.remove('connected'); };
    ws.onmessage = handleMessage;
  }

  // â”€â”€ Message Handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function handleMessage(evt) {
    const msg = JSON.parse(evt.data);
    
    switch (msg.type) {
      case 'state':
        setState(msg.state);
        break;
        
      case 'transcript':
        if (msg.role === 'user') showUserText(msg.text);
        break;
        
      case 'streaming_start':
        streamingIndicator.classList.add('active');
        nextStartTime = 0; // Reset audio timing
        audioQueue = [];
        break;
        
      case 'text_chunk':
        showResponseText(msg.text, true); // Append mode
        break;
        
      case 'audio_chunk':
        // Queue and play audio chunk
        const audioBytes = Uint8Array.from(atob(msg.audio), c => c.charCodeAt(0));
        audioQueue.push(audioBytes);
        playAudioChunk(audioBytes.buffer.slice());
        break;
        
      case 'response_complete':
        showLatency(msg.first_audio_latency, msg.total_time);
        break;
        
      case 'streaming_complete':
        streamingIndicator.classList.remove('active');
        break;
        
      case 'error':
        showUserText(msg.message);
        setState('idle');
        break;
        
      case 'pong':
        // Heartbeat response
        break;
    }
  }

  connectWS();

  // â”€â”€ Text Display â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  const responseTextEl = document.getElementById('response-text');
  let fadeOutTimer = null;
  let currentText = '';

  function showUserText(text) {
    transcriptEl.textContent = text;
  }

  function showResponseText(text, append = false) {
    clearTimeout(fadeOutTimer);
    
    if (append) {
      currentText += text;
      responseTextEl.textContent = currentText;
    } else {
      currentText = text;
      responseTextEl.textContent = text;
    }
    
    responseTextEl.className = '';
    void responseTextEl.offsetWidth; // Trigger reflow
    responseTextEl.className = 'visible';
  }

  function hideResponseText() {
    responseTextEl.className = 'visible fade-out';
    fadeOutTimer = setTimeout(() => {
      responseTextEl.className = '';
      responseTextEl.textContent = '';
      currentText = '';
    }, 1000);
  }

  function showLatency(firstAudioLatency, totalTime) {
    if (firstAudioLatency) {
      latencyDisplay.innerHTML = `
        ðŸŽ¯ ${(firstAudioLatency * 1000).toFixed(0)}ms to first audio<br>
        â±ï¸ ${(totalTime * 1000).toFixed(0)}ms total LLM
      `;
      latencyDisplay.classList.add('visible');
      setTimeout(() => latencyDisplay.classList.remove('visible'), 3000);
    }
  }

  // â”€â”€ Mic Recording â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  let silenceTimer = null;
  let hasSpoken = false;
  const SILENCE_THRESHOLD = 0.04;
  const SILENCE_DURATION = 1500;
  const MAX_RECORD_TIME = 15000;
  let maxRecordTimer = null;

  async function startRecording() {
    await initAudioContext();
    try {
      micStream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16000,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true
        }
      });
    } catch (e) {
      console.warn('Mic denied', e);
      showUserText('microphone access denied');
      return false;
    }

    const src = streamingAudioCtx.createMediaStreamSource(micStream);
    analyser = streamingAudioCtx.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    src.connect(analyser);

    audioChunks = [];
    hasSpoken = false;
    silenceTimer = null;

    const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') 
      ? 'audio/webm;codecs=opus' : 'audio/webm';
    mediaRecorder = new MediaRecorder(micStream, { mimeType });
    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };
    mediaRecorder.start(100);

    maxRecordTimer = setTimeout(() => finishRecording(), MAX_RECORD_TIME);
    return true;
  }

  async function finishRecording() {
    if (state !== 'listening') return;
    clearTimeout(maxRecordTimer);
    clearTimeout(silenceTimer);
    setState('thinking');
    const b64 = await stopRecording();
    if (b64 && wsReady) {
      ws.send(JSON.stringify({ type: 'audio', audio: b64 }));
    } else if (!wsReady) {
      showUserText('not connected');
      setState('idle');
    }
  }

  async function stopRecording() {
    if (!mediaRecorder || mediaRecorder.state === 'inactive') return null;
    return new Promise(resolve => {
      mediaRecorder.onstop = async () => {
        if (micStream) {
          micStream.getTracks().forEach(t => t.stop());
          micStream = null;
        }
        const blob = new Blob(audioChunks, { type: 'audio/webm' });
        const buffer = await blob.arrayBuffer();
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        resolve(btoa(binary));
      };
      mediaRecorder.stop();
    });
  }

  function pollMic() {
    if (state !== 'listening') {
      targetAmplitude = 0;
      return;
    }
    requestAnimationFrame(pollMic);
    if (analyser && dataArray) {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
      const amp = (sum / dataArray.length) / 255;
      targetAmplitude = amp;

      if (amp > SILENCE_THRESHOLD) {
        hasSpoken = true;
        clearTimeout(silenceTimer);
        silenceTimer = null;
      } else if (hasSpoken && !silenceTimer) {
        silenceTimer = setTimeout(() => finishRecording(), SILENCE_DURATION);
      }
    }
  }

  // â”€â”€ Circle Visualizer â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function draw() {
    requestAnimationFrame(draw);
    ctx.clearRect(0, 0, W, H);
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, W, H);

    breathPhase += 0.015;
    amplitude += (targetAmplitude - amplitude) * 0.12;

    const cx = W/2, cy = H * 0.42;
    const br = Math.min(W, H) * 0.12;

    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    ctx.lineWidth = 2.5 * devicePixelRatio;
    ctx.beginPath();

    const pts = 128;
    for (let i = 0; i <= pts; i++) {
      const a = (i/pts) * Math.PI * 2;
      let r = br;

      if (state === 'idle') {
        r += Math.sin(breathPhase) * br * 0.03;
      } else if (state === 'listening' || state === 'speaking') {
        const w = amplitude * br * 0.5;
        r += Math.sin(a*3 + breathPhase*2) * w * 0.4;
        r += Math.sin(a*5 - breathPhase*1.5) * w * 0.25;
        r += Math.sin(a*7 + breathPhase*3) * w * 0.15;
        r += w * 0.2;
      } else if (state === 'thinking') {
        r += Math.sin(breathPhase*3) * br * 0.08;
        r += Math.sin(a*2 + breathPhase*0.8) * br * 0.04;
      }

      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
  requestAnimationFrame(draw);

  // â”€â”€ State Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  function setState(s) {
    state = s;
    const labels = {
      idle: 'tap to talk',
      listening: 'listening',
      thinking: 'thinking',
      speaking: ''
    };
    statusEl.textContent = labels[s] || s;
    statusEl.style.opacity = s === 'idle' ? '0.4' : '0.6';
    
    if (s === 'listening') pollMic();
    if (s !== 'listening' && s !== 'speaking') targetAmplitude = 0;
    
    // Reset streaming state when going to idle
    if (s === 'idle') {
      currentText = '';
      audioQueue = [];
      isPlaying = false;
      nextStartTime = 0;
    }
  }

  // â”€â”€ Tap Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  mainEl.addEventListener('click', async () => {
    if (state === 'speaking' || state === 'thinking') return;

    if (state === 'listening') {
      finishRecording();
      return;
    }

    // Start recording
    hideResponseText();
    transcriptEl.textContent = '';
    const ok = await startRecording();
    if (ok) setState('listening');
  });
}

})();
</script>
</body>
</html>