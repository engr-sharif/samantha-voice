<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#FF4F38">
<meta name="mobile-web-app-capable" content="yes">
<title>Samantha</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Helvetica Neue',sans-serif;background:#FF4F38;color:rgba(0,0,0,0.7);touch-action:manipulation}
body{padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}

#pin-screen,#boot-screen,#main-screen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center}
#pin-screen{z-index:30}
#boot-screen{z-index:20;opacity:0;pointer-events:none}
#main-screen{z-index:10;opacity:0;pointer-events:none}

/* PIN */
.pin-dots{display:flex;gap:18px;margin-bottom:48px}
.pin-dot{width:16px;height:16px;border-radius:50%;border:2px solid rgba(0,0,0,0.5);transition:background .15s}
.pin-dot.filled{background:rgba(0,0,0,0.8);border-color:rgba(0,0,0,0.8)}
.keypad{display:grid;grid-template-columns:repeat(3,80px);gap:12px}
.key{width:80px;height:80px;border-radius:50%;border:1.5px solid rgba(0,0,0,0.35);background:transparent;color:rgba(0,0,0,0.8);font-size:28px;font-weight:300;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .1s,transform .1s;user-select:none}
.key:active{background:rgba(0,0,0,0.1);transform:scale(0.95)}
.key.zero{grid-column:2}
.key.del{border:none;font-size:16px;letter-spacing:1px}
.pin-error{color:rgba(0,0,0,0.6);font-size:13px;height:20px;margin-bottom:24px;letter-spacing:1px}

/* Boot */
#boot-canvas{width:100%;height:100%}

/* Main */
#viz-canvas{position:absolute;inset:0;width:100%;height:100%}
#status{position:absolute;bottom:calc(60px + env(safe-area-inset-bottom));left:0;right:0;text-align:center;font-size:13px;letter-spacing:2px;text-transform:uppercase;opacity:0.5;transition:opacity .3s}
#transcript{position:absolute;bottom:calc(20px + env(safe-area-inset-bottom));left:20px;right:20px;text-align:center;font-size:13px;color:rgba(0,0,0,0.45);max-height:60px;overflow:hidden;line-height:1.4}
</style>
</head>
<body>

<!-- PIN Screen -->
<div id="pin-screen">
  <div class="pin-error" id="pin-error"></div>
  <div class="pin-dots" id="pin-dots">
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
  </div>
  <div class="keypad" id="keypad">
    <div class="key" data-n="1">1</div><div class="key" data-n="2">2</div><div class="key" data-n="3">3</div>
    <div class="key" data-n="4">4</div><div class="key" data-n="5">5</div><div class="key" data-n="6">6</div>
    <div class="key" data-n="7">7</div><div class="key" data-n="8">8</div><div class="key" data-n="9">9</div>
    <div class="key del" data-n="del">DEL</div><div class="key zero" data-n="0">0</div>
  </div>
</div>

<!-- Boot Screen (Three.js) -->
<div id="boot-screen"><canvas id="boot-canvas"></canvas></div>

<!-- Main Screen -->
<div id="main-screen">
  <canvas id="viz-canvas"></canvas>
  <div id="status">tap to talk</div>
  <div id="transcript"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function(){
'use strict';

const PIN_CODE = '0913';
const BG = '#FF4F38';
let pinEntry = '';
const dots = document.querySelectorAll('.pin-dot');
const pinError = document.getElementById('pin-error');

// PIN
document.getElementById('keypad').addEventListener('click', e => {
  const k = e.target.closest('.key');
  if (!k) return;
  const n = k.dataset.n;
  if (n === 'del') { pinEntry = pinEntry.slice(0,-1); updateDots(); return; }
  if (pinEntry.length >= 4) return;
  pinEntry += n;
  updateDots();
  if (pinEntry.length === 4) {
    if (pinEntry === PIN_CODE) {
      setTimeout(startBoot, 200);
    } else {
      pinError.textContent = 'incorrect';
      document.getElementById('pin-dots').style.animation = 'shake .4s';
      setTimeout(() => {
        pinEntry = ''; updateDots(); pinError.textContent = '';
        document.getElementById('pin-dots').style.animation = '';
      }, 600);
    }
  }
});
function updateDots() {
  dots.forEach((d,i) => d.classList.toggle('filled', i < pinEntry.length));
}

// Add shake animation
const ss = document.createElement('style');
ss.textContent = '@keyframes shake{0%,100%{transform:translateX(0)}25%{transform:translateX(-12px)}75%{transform:translateX(12px)}}';
document.head.appendChild(ss);

// BOOT
function startBoot() {
  document.getElementById('pin-screen').style.opacity = '0';
  document.getElementById('pin-screen').style.transition = 'opacity .4s';
  setTimeout(() => { document.getElementById('pin-screen').style.display = 'none'; }, 400);

  const bootEl = document.getElementById('boot-screen');
  bootEl.style.opacity = '1';
  bootEl.style.pointerEvents = 'auto';

  const canvas = document.getElementById('boot-canvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
  renderer.setClearColor(new THREE.Color(BG));
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.z = 80;

  // Infinity curve
  const pi2 = Math.PI * 2;
  const length = 30, radius = 5.6;
  const curve = new THREE.Curve();
  curve.getPoint = function(percent) {
    var x = length * Math.sin(pi2 * percent),
        y = radius * Math.cos(pi2 * 3 * percent),
        z, t;
    t = percent % 0.25 / 0.25;
    t = percent % 0.25 - (2 * (1 - t) * t * -0.0185 + t * t * 0.25);
    if (Math.floor(percent / 0.25) == 0 || Math.floor(percent / 0.25) == 2) t *= -1;
    z = radius * Math.sin(pi2 * 2 * (percent - t));
    return new THREE.Vector3(x, y, z);
  };

  const geo = new THREE.TubeGeometry(curve, 200, 1.1, 2, true);
  const mat = new THREE.MeshBasicMaterial({ color: 0x000000 });
  const mesh = new THREE.Mesh(geo, mat);
  const group = new THREE.Group();
  group.add(mesh);
  scene.add(group);

  let startTime = performance.now();
  let transitionStarted = false;
  let bootDone = false;

  function easeInOut(t) { return t < 0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }

  function animateBoot() {
    if (bootDone) return;
    requestAnimationFrame(animateBoot);
    const elapsed = (performance.now() - startTime) / 1000;

    if (!transitionStarted) {
      mesh.rotation.x += 0.035;
      if (elapsed > 2.8) { transitionStarted = true; startTime = performance.now(); }
    } else {
      const dur = 1.8;
      const t = Math.min((performance.now() - startTime) / 1000 / dur, 1);
      const e = easeInOut(t);
      group.rotation.y = -e * Math.PI / 2;
      group.position.z = e * 40;
      mat.opacity = 1 - Math.pow(t, 2);
      mat.transparent = true;

      if (t >= 1) {
        bootDone = true;
        bootEl.style.transition = 'opacity .6s';
        bootEl.style.opacity = '0';
        setTimeout(() => {
          bootEl.style.display = 'none';
          renderer.dispose();
          startMain();
        }, 600);
      }
    }
    renderer.render(scene, camera);
  }
  animateBoot();
}

// MAIN
function startMain() {
  const mainEl = document.getElementById('main-screen');
  mainEl.style.opacity = '1';
  mainEl.style.pointerEvents = 'auto';
  mainEl.style.transition = 'opacity .8s';

  const canvas = document.getElementById('viz-canvas');
  const ctx = canvas.getContext('2d');
  let W, H;
  function resize() {
    W = canvas.width = window.innerWidth * devicePixelRatio;
    H = canvas.height = window.innerHeight * devicePixelRatio;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
  }
  resize();
  window.addEventListener('resize', resize);

  const statusEl = document.getElementById('status');
  const transcriptEl = document.getElementById('transcript');

  // States: idle, listening, thinking, speaking
  let state = 'idle';
  let audioCtx, analyser, dataArray, micStream;
  let amplitude = 0;
  let targetAmplitude = 0;

  // Circle params
  const baseRadius = Math.min(W, H) * 0.12;
  let breathPhase = 0;

  function drawCircle(time) {
    requestAnimationFrame(drawCircle);
    ctx.clearRect(0, 0, W, H);
    // BG
    ctx.fillStyle = BG;
    ctx.fillRect(0, 0, W, H);

    breathPhase += 0.015;
    amplitude += (targetAmplitude - amplitude) * 0.12;

    const cx = W / 2, cy = H / 2;
    const br = Math.min(W, H) * 0.12;

    ctx.strokeStyle = 'rgba(0,0,0,0.85)';
    ctx.lineWidth = 2.5 * devicePixelRatio;
    ctx.beginPath();

    const points = 128;
    for (let i = 0; i <= points; i++) {
      const a = (i / points) * Math.PI * 2;
      let r = br;

      // Breathing
      if (state === 'idle') {
        r += Math.sin(breathPhase) * br * 0.03;
      }
      // Voice response
      if (state === 'listening' || state === 'speaking') {
        // Organic wobble from audio
        const wobble = amplitude * br * 0.5;
        r += Math.sin(a * 3 + breathPhase * 2) * wobble * 0.4;
        r += Math.sin(a * 5 - breathPhase * 1.5) * wobble * 0.25;
        r += Math.sin(a * 7 + breathPhase * 3) * wobble * 0.15;
        r += wobble * 0.2;
      }
      // Thinking pulse
      if (state === 'thinking') {
        r += Math.sin(breathPhase * 3) * br * 0.08;
        // Rotation effect
        const rot = breathPhase * 0.8;
        r += Math.sin(a * 2 + rot) * br * 0.04;
      }

      const x = cx + Math.cos(a) * r;
      const y = cy + Math.sin(a) * r;
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.stroke();
  }
  requestAnimationFrame(drawCircle);

  // Audio
  async function startMic() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    try {
      micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const src = audioCtx.createMediaStreamSource(micStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 256;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      src.connect(analyser);
      pollAudio();
    } catch(e) {
      console.warn('Mic denied', e);
    }
  }

  function pollAudio() {
    if (state !== 'listening') { targetAmplitude = 0; return; }
    requestAnimationFrame(pollAudio);
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    targetAmplitude = (sum / dataArray.length) / 255;
  }

  function stopMic() {
    if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
    targetAmplitude = 0;
  }

  // STT placeholder
  let recognition;
  try {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SR) {
      recognition = new SR();
      recognition.continuous = false;
      recognition.interimResults = true;
      recognition.lang = 'en-US';
      recognition.onresult = e => {
        let final = '', interim = '';
        for (let i = e.resultIndex; i < e.results.length; i++) {
          if (e.results[i].isFinal) final += e.results[i][0].transcript;
          else interim += e.results[i][0].transcript;
        }
        transcriptEl.textContent = final || interim;
        if (final) {
          setState('thinking');
          setTimeout(() => {
            respond(final);
          }, 1200);
        }
      };
      recognition.onerror = () => setState('idle');
      recognition.onend = () => { if (state === 'listening') setState('idle'); };
    }
  } catch(e) {}

  function respond(text) {
    // Placeholder TTS
    setState('speaking');
    const reply = "I'm here.";
    transcriptEl.textContent = reply;
    if ('speechSynthesis' in window) {
      const u = new SpeechSynthesisUtterance(reply);
      u.rate = 0.95; u.pitch = 1.1;
      // Simulate amplitude during speech
      const pulseInterval = setInterval(() => {
        targetAmplitude = 0.2 + Math.random() * 0.3;
      }, 80);
      u.onend = () => { clearInterval(pulseInterval); targetAmplitude = 0; setState('idle'); };
      speechSynthesis.speak(u);
    } else {
      setTimeout(() => { targetAmplitude = 0; setState('idle'); }, 2000);
    }
  }

  function setState(s) {
    state = s;
    statusEl.textContent = s === 'idle' ? 'tap to talk' : s === 'listening' ? 'listening' : s === 'thinking' ? 'thinking' : 'speaking';
    statusEl.style.opacity = s === 'idle' ? '0.4' : '0.6';
    if (s === 'listening') pollAudio();
    if (s !== 'listening') targetAmplitude = 0;
  }

  // Tap to talk
  mainEl.addEventListener('click', async () => {
    if (state === 'speaking' || state === 'thinking') return;
    if (state === 'listening') { setState('idle'); stopMic(); return; }
    await startMic();
    setState('listening');
    if (recognition) {
      try { recognition.start(); } catch(e) {}
    }
  });
}

})();
</script>
</body>
</html>
