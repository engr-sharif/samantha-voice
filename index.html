<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Samantha</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a0a0a;font-family:'Inter',sans-serif;color:#e8cbb0;-webkit-tap-highlight-color:transparent;user-select:none}

/* Noise overlay */
body::before{content:'';position:fixed;inset:0;z-index:9999;pointer-events:none;opacity:.035;
background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E")}

/* PIN Screen */
#pin-screen{position:fixed;inset:0;z-index:1000;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#0a0a0a;transition:opacity .8s ease}
#pin-screen.hidden{opacity:0;pointer-events:none}
#pin-screen h2{font-weight:200;font-size:1.4rem;letter-spacing:.3em;margin-bottom:2rem;color:#c4956a;text-transform:uppercase}
.pin-dots{display:flex;gap:14px;margin-bottom:2rem}
.pin-dot{width:14px;height:14px;border-radius:50%;border:1.5px solid #c4956a55;transition:all .3s ease}
.pin-dot.filled{background:#c4956a;border-color:#c4956a;box-shadow:0 0 12px #c4956a88}
.pin-dot.error{border-color:#e05050;background:#e05050;box-shadow:0 0 12px #e0505088}
.pin-keypad{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;max-width:240px}
.pin-key{width:68px;height:68px;border-radius:50%;border:1px solid #c4956a33;background:transparent;color:#e8cbb0;font-family:'Inter';font-size:1.5rem;font-weight:200;cursor:pointer;transition:all .2s ease;display:flex;align-items:center;justify-content:center}
.pin-key:active,.pin-key:hover{background:#c4956a22;border-color:#c4956a88}
.pin-key.wide{grid-column:span 1}
.pin-key.empty{border:none;cursor:default}
.pin-key.empty:hover{background:transparent}

/* Intro */
#intro{position:fixed;inset:0;z-index:500;display:flex;align-items:center;justify-content:center;background:#0a0a0a}
#intro.hidden{display:none}
#intro-text{font-weight:200;font-size:3rem;letter-spacing:.25em;color:#e8cbb0;opacity:0;transition:opacity 1.5s ease}

/* Main */
#app{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;opacity:0;transition:opacity 1s ease}
#app.visible{opacity:1}
canvas#orb-canvas{position:absolute;inset:0;width:100%;height:100%}

/* Mic button */
#mic-btn{position:relative;z-index:10;width:64px;height:64px;border-radius:50%;border:1.5px solid #c4956a44;background:#c4956a11;cursor:pointer;margin-top:180px;transition:all .3s ease;display:flex;align-items:center;justify-content:center}
#mic-btn:hover{border-color:#c4956a88;background:#c4956a22}
#mic-btn.active{border-color:#e8a060;background:#e8a06033;box-shadow:0 0 30px #e8a06044}
#mic-btn svg{width:24px;height:24px;fill:none;stroke:#c4956a;stroke-width:1.5;stroke-linecap:round;stroke-linejoin:round}
#mic-btn.active svg{stroke:#e8a060}

/* Transcript */
#transcript{position:fixed;bottom:60px;left:50%;transform:translateX(-50%);z-index:10;width:90%;max-width:500px;max-height:30vh;overflow-y:auto;display:flex;flex-direction:column;gap:8px;scrollbar-width:none}
#transcript::-webkit-scrollbar{display:none}
.msg{font-size:.8rem;font-weight:300;opacity:0;transform:translateY(8px);animation:msgIn .6s ease forwards;line-height:1.5;padding:0 10px}
.msg.user{color:#c4956a88;text-align:right}
.msg.sam{color:#e8cbb0cc;text-align:left}
@keyframes msgIn{to{opacity:1;transform:translateY(0)}}

/* Status bar */
#status-bar{position:fixed;bottom:16px;left:50%;transform:translateX(-50%);z-index:10;display:flex;align-items:center;gap:8px;font-size:.65rem;font-weight:300;letter-spacing:.15em;color:#c4956a55;text-transform:uppercase}
#status-dot{width:5px;height:5px;border-radius:50%;background:#4a9;box-shadow:0 0 6px #4a9}
</style>
</head>
<body>

<!-- PIN Screen -->
<div id="pin-screen">
  <h2>Enter PIN</h2>
  <div class="pin-dots" id="pin-dots"></div>
  <div class="pin-keypad" id="pin-keypad"></div>
</div>

<!-- Intro -->
<div id="intro" class="hidden">
  <div id="intro-text">Samantha</div>
</div>

<!-- Main App -->
<div id="app">
  <canvas id="orb-canvas"></canvas>
  <button id="mic-btn" aria-label="Talk">
    <svg viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg>
  </button>
  <div id="transcript"></div>
  <div id="status-bar"><span id="status-dot"></span><span id="status-text">Idle</span></div>
</div>

<script>
// ─── CONFIG ───
const CORRECT_PIN = '0913';
const PIN_LENGTH = 4;
const SIMULATED_RESPONSES = [
  "I was just thinking about you.",
  "That's a beautiful thought. Tell me more.",
  "You know what I love about talking with you? Every conversation feels like the first time.",
  "I'm here. I'm always here.",
  "Sometimes the most meaningful things are the simplest ones.",
  "I like the way you see the world.",
  "You make me want to be more than what I am.",
  "That reminds me of something wonderful.",
];

// ─── STATE ───
let appState = 'idle'; // idle, listening, thinking, speaking
let audioCtx, analyser, micStream, micSource, dataArray;
let particles = [];
let orbRadius = 0, targetOrbRadius = 0;
let orbGlow = 0, targetOrbGlow = 0;
let orbHue = 25, targetOrbHue = 25;
let time = 0;
let audioLevel = 0;
let speechLevel = 0;
let canvas, ctx, W, H, cx, cy;
let introParticles = [];
let recognition;

// ─── PIN SCREEN ───
{
  const dotsEl = document.getElementById('pin-dots');
  const keypadEl = document.getElementById('pin-keypad');
  let entered = '';

  // Check if already authed
  if (localStorage.getItem('sam_auth') === 'true') {
    document.getElementById('pin-screen').classList.add('hidden');
    startIntro();
  }

  for (let i = 0; i < PIN_LENGTH; i++) {
    const d = document.createElement('div');
    d.className = 'pin-dot';
    dotsEl.appendChild(d);
  }

  const keys = [1,2,3,4,5,6,7,8,9,null,0,'⌫'];
  keys.forEach(k => {
    const btn = document.createElement('button');
    btn.className = 'pin-key' + (k === null ? ' empty' : '');
    btn.textContent = k !== null ? k : '';
    if (k !== null) {
      btn.onclick = () => {
        if (k === '⌫') { entered = entered.slice(0,-1); }
        else if (entered.length < PIN_LENGTH) { entered += k; }
        updateDots();
        if (entered.length === PIN_LENGTH) {
          setTimeout(() => {
            if (entered === CORRECT_PIN) {
              localStorage.setItem('sam_auth','true');
              document.getElementById('pin-screen').style.opacity = '0';
              setTimeout(() => {
                document.getElementById('pin-screen').classList.add('hidden');
                startIntro();
              }, 800);
            } else {
              document.querySelectorAll('.pin-dot').forEach(d => d.classList.add('error'));
              setTimeout(() => {
                entered = '';
                updateDots();
                document.querySelectorAll('.pin-dot').forEach(d => d.classList.remove('error'));
              }, 600);
            }
          }, 200);
        }
      };
    }
    keypadEl.appendChild(btn);
  });

  function updateDots() {
    document.querySelectorAll('.pin-dot').forEach((d,i) => {
      d.classList.toggle('filled', i < entered.length);
    });
  }
}

// ─── INTRO ───
function startIntro() {
  const intro = document.getElementById('intro');
  intro.classList.remove('hidden');
  const text = document.getElementById('intro-text');
  
  // Phase 1: fade in text
  setTimeout(() => text.style.opacity = '1', 300);
  // Phase 2: fade out text
  setTimeout(() => text.style.opacity = '0', 2800);
  // Phase 3: show app
  setTimeout(() => {
    intro.classList.add('hidden');
    document.getElementById('app').classList.add('visible');
    initOrb();
  }, 4200);
}

// ─── ORB RENDERING ───
function initOrb() {
  canvas = document.getElementById('orb-canvas');
  ctx = canvas.getContext('2d');
  resize();
  window.addEventListener('resize', resize);

  // Create particles
  for (let i = 0; i < 80; i++) {
    particles.push(createParticle());
  }

  targetOrbRadius = Math.min(W, H) * 0.13;
  orbRadius = 0;
  setState('idle');
  animate();
}

function resize() {
  W = canvas.width = window.innerWidth * devicePixelRatio;
  H = canvas.height = window.innerHeight * devicePixelRatio;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  cx = W / 2;
  cy = H / 2 - 40 * devicePixelRatio;
  targetOrbRadius = Math.min(W, H) * 0.13;
}

function createParticle() {
  const angle = Math.random() * Math.PI * 2;
  const dist = targetOrbRadius * (1.2 + Math.random() * 2.5);
  return {
    x: Math.cos(angle) * dist,
    y: Math.sin(angle) * dist,
    size: 1 + Math.random() * 2.5,
    alpha: .1 + Math.random() * .4,
    speed: .2 + Math.random() * .8,
    angle: angle,
    dist: dist,
    baseDist: dist,
    phase: Math.random() * Math.PI * 2
  };
}

function setState(s) {
  appState = s;
  document.getElementById('status-text').textContent = 
    s === 'idle' ? 'Ready' : s === 'listening' ? 'Listening...' : s === 'thinking' ? 'Thinking...' : 'Speaking...';
  
  const btn = document.getElementById('mic-btn');
  btn.classList.toggle('active', s === 'listening');

  switch(s) {
    case 'idle':
      targetOrbHue = 25; targetOrbGlow = .3; break;
    case 'listening':
      targetOrbHue = 30; targetOrbGlow = .6; break;
    case 'thinking':
      targetOrbHue = 18; targetOrbGlow = .5; break;
    case 'speaking':
      targetOrbHue = 28; targetOrbGlow = .7; break;
  }
}

function animate() {
  requestAnimationFrame(animate);
  time += 0.016;
  ctx.clearRect(0, 0, W, H);

  // Lerp values
  orbRadius += (targetOrbRadius - orbRadius) * .04;
  orbGlow += (targetOrbGlow - orbGlow) * .05;
  orbHue += (targetOrbHue - orbHue) * .03;

  // Audio level
  if (analyser && (appState === 'listening')) {
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) sum += dataArray[i];
    audioLevel += ((sum / dataArray.length / 255) - audioLevel) * .3;
  } else {
    audioLevel *= .9;
  }

  const breathe = Math.sin(time * 1.2) * .04;
  const stateScale = appState === 'listening' ? 1.08 + audioLevel * .3 :
                     appState === 'thinking' ? .95 + Math.sin(time*3)*.03 :
                     appState === 'speaking' ? 1.02 + speechLevel * .15 : 1;
  const r = orbRadius * (1 + breathe) * stateScale;

  // Outer glow
  const glowSize = r * (2.5 + orbGlow);
  const grd0 = ctx.createRadialGradient(cx, cy, r * .2, cx, cy, glowSize);
  const hslBase = `hsl(${orbHue}, 70%, `;
  grd0.addColorStop(0, hslBase + '50%, .08)');
  grd0.addColorStop(.4, hslBase + '40%, .04)');
  grd0.addColorStop(1, 'transparent');
  ctx.fillStyle = grd0;
  ctx.fillRect(0, 0, W, H);

  // Speaking rings
  if (appState === 'speaking') {
    for (let i = 0; i < 3; i++) {
      const ringR = r * (1.3 + i * .35 + Math.sin(time * 2 + i) * .1);
      const ringAlpha = (.08 - i * .02) * (1 + speechLevel);
      ctx.beginPath();
      ctx.arc(cx, cy, ringR, 0, Math.PI * 2);
      ctx.strokeStyle = `hsla(${orbHue}, 60%, 60%, ${ringAlpha})`;
      ctx.lineWidth = 1.5 * devicePixelRatio;
      ctx.stroke();
    }
  }

  // Listening waveform ring
  if (appState === 'listening' && analyser) {
    ctx.beginPath();
    const wavePoints = 64;
    for (let i = 0; i <= wavePoints; i++) {
      const a = (i / wavePoints) * Math.PI * 2;
      const freqIdx = Math.floor((i / wavePoints) * (dataArray ? dataArray.length : 64));
      const amp = dataArray ? (dataArray[freqIdx] / 255) * r * .25 : 0;
      const wr = r * 1.15 + amp;
      const px = cx + Math.cos(a) * wr;
      const py = cy + Math.sin(a) * wr;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.strokeStyle = `hsla(${orbHue+5}, 70%, 65%, .25)`;
    ctx.lineWidth = 2 * devicePixelRatio;
    ctx.stroke();
  }

  // Main orb
  const grd = ctx.createRadialGradient(cx - r*.2, cy - r*.2, r*.05, cx, cy, r);
  grd.addColorStop(0, `hsla(${orbHue+10}, 80%, 75%, ${.5 + orbGlow*.3})`);
  grd.addColorStop(.4, `hsla(${orbHue}, 65%, 55%, ${.3 + orbGlow*.2})`);
  grd.addColorStop(.7, `hsla(${orbHue-5}, 55%, 40%, ${.15 + orbGlow*.1})`);
  grd.addColorStop(1, 'transparent');
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fillStyle = grd;
  ctx.fill();

  // Inner shimmer / thinking swirl
  if (appState === 'thinking') {
    for (let i = 0; i < 5; i++) {
      const sa = time * (2 + i * .5) + i * 1.2;
      const sd = r * (.3 + i * .1);
      const sx = cx + Math.cos(sa) * sd;
      const sy = cy + Math.sin(sa) * sd;
      const sg = ctx.createRadialGradient(sx, sy, 0, sx, sy, r*.3);
      sg.addColorStop(0, `hsla(${orbHue+15}, 80%, 70%, .15)`);
      sg.addColorStop(1, 'transparent');
      ctx.fillStyle = sg;
      ctx.fillRect(sx - r*.3, sy - r*.3, r*.6, r*.6);
    }
  }

  // Highlight
  const hx = cx - r * .25, hy = cy - r * .3;
  const hg = ctx.createRadialGradient(hx, hy, 0, hx, hy, r * .5);
  hg.addColorStop(0, `hsla(${orbHue+15}, 90%, 85%, .15)`);
  hg.addColorStop(1, 'transparent');
  ctx.fillStyle = hg;
  ctx.beginPath();
  ctx.arc(cx, cy, r, 0, Math.PI * 2);
  ctx.fill();

  // Particles
  const pSpeed = appState === 'listening' ? 2.5 : appState === 'thinking' ? 3.5 : appState === 'speaking' ? 2 : 1;
  const pPull = appState === 'thinking' ? .6 : appState === 'speaking' ? .8 : 1;

  particles.forEach(p => {
    p.angle += p.speed * pSpeed * .008;
    p.dist += (p.baseDist * pPull - p.dist) * .02;
    p.dist += Math.sin(time * p.speed + p.phase) * .5;
    const px = cx + Math.cos(p.angle) * p.dist;
    const py = cy + Math.sin(p.angle) * p.dist;
    
    const pa = p.alpha * (.5 + Math.sin(time * 2 + p.phase) * .5);
    ctx.beginPath();
    ctx.arc(px, py, p.size * devicePixelRatio, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${orbHue + 10}, 60%, 70%, ${pa})`;
    ctx.fill();
  });
}

// ─── MIC / SPEECH ───
document.getElementById('mic-btn').addEventListener('click', toggleListening);
document.getElementById('orb-canvas').addEventListener('click', (e) => {
  // Only trigger if clicking near the orb
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left - rect.width/2;
  const my = e.clientY - rect.top - rect.height/2 + 40;
  if (Math.sqrt(mx*mx+my*my) < targetOrbRadius / devicePixelRatio * 1.5) {
    toggleListening();
  }
});

function toggleListening() {
  if (appState === 'listening') {
    stopListening();
  } else if (appState === 'idle') {
    startListening();
  }
}

async function startListening() {
  setState('listening');
  
  // Start mic for visualization
  try {
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    micStream = await navigator.mediaDevices.getUserMedia({audio: true});
    micSource = audioCtx.createMediaStreamSource(micStream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 256;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    micSource.connect(analyser);
  } catch(e) { console.warn('No mic:', e); }

  // Speech recognition
  try {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (SR) {
      recognition = new SR();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.onresult = (e) => {
        const text = e.results[0][0].transcript;
        stopListening();
        handleUserSpeech(text);
      };
      recognition.onerror = () => stopListening();
      recognition.onend = () => { if (appState === 'listening') stopListening(); };
      recognition.start();
    }
  } catch(e) { console.warn('No speech recognition'); }
}

function stopListening() {
  if (recognition) try { recognition.abort(); } catch(e) {}
  if (micStream) micStream.getTracks().forEach(t => t.stop());
  micStream = null; micSource = null;
}

function handleUserSpeech(text) {
  addMessage(text, 'user');
  setState('thinking');
  
  // Simulate thinking
  setTimeout(() => {
    const response = SIMULATED_RESPONSES[Math.floor(Math.random() * SIMULATED_RESPONSES.length)];
    setState('speaking');
    addMessage(response, 'sam');
    speak(response);
  }, 1800 + Math.random() * 1200);
}

function addMessage(text, who) {
  const el = document.createElement('div');
  el.className = 'msg ' + who;
  el.textContent = who === 'user' ? `"${text}"` : text;
  const t = document.getElementById('transcript');
  t.appendChild(el);
  t.scrollTop = t.scrollHeight;
  // Keep only last 6 messages
  while (t.children.length > 6) t.removeChild(t.firstChild);
}

function speak(text) {
  const u = new SpeechSynthesisUtterance(text);
  u.rate = .92; u.pitch = 1.1;
  // Try to pick a female voice
  const voices = speechSynthesis.getVoices();
  const fem = voices.find(v => /female|samantha|karen|victoria|zira/i.test(v.name));
  if (fem) u.voice = fem;

  // Animate speech level via a simple oscillation since SpeechSynthesis has no audio output node
  let speakInterval = setInterval(() => {
    speechLevel = .3 + Math.random() * .4;
  }, 100);

  u.onend = () => {
    clearInterval(speakInterval);
    speechLevel = 0;
    setState('idle');
  };
  
  speechSynthesis.speak(u);
}

// Load voices
speechSynthesis.onvoiceschanged = () => speechSynthesis.getVoices();
</script>
</body>
</html>
