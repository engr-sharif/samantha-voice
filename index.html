<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#FF4F38">
<title>Samantha</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{width:100%;height:100%;overflow:hidden;font-family:-apple-system,BlinkMacSystemFont,'Helvetica Neue',sans-serif;background:#FF4F38;color:rgba(0,0,0,0.7);touch-action:manipulation}
body{padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}

.screen{position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;transition:opacity .4s}
.hidden{opacity:0;pointer-events:none}

/* PIN Screen */
#pin-screen{z-index:30}
.pin-dots{display:flex;gap:18px;margin-bottom:48px}
.pin-dot{width:16px;height:16px;border-radius:50%;border:2px solid rgba(0,0,0,0.5);transition:background .15s}
.pin-dot.filled{background:rgba(0,0,0,0.8);border-color:rgba(0,0,0,0.8)}
.keypad{display:grid;grid-template-columns:repeat(3,80px);gap:12px}
.key{width:80px;height:80px;border-radius:50%;border:1.5px solid rgba(0,0,0,0.35);background:transparent;color:rgba(0,0,0,0.8);font-size:28px;font-weight:300;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:background .1s,transform .1s;user-select:none}
.key:active{background:rgba(0,0,0,0.1);transform:scale(0.95)}
.key.zero{grid-column:2}
.key.del{border:none;font-size:16px;letter-spacing:1px}
.pin-error{color:rgba(0,0,0,0.6);font-size:13px;height:20px;margin-bottom:24px;letter-spacing:1px}

/* Setup Screen */
#setup-screen{z-index:25}
.setup-box{width:min(340px,85vw);text-align:center}
.setup-box h2{font-size:18px;font-weight:500;margin-bottom:8px;color:rgba(0,0,0,0.8)}
.setup-box p{font-size:13px;color:rgba(0,0,0,0.5);margin-bottom:24px;line-height:1.5}
.setup-input{width:100%;padding:14px 16px;border-radius:12px;border:1.5px solid rgba(0,0,0,0.2);background:rgba(255,255,255,0.15);color:rgba(0,0,0,0.8);font-size:15px;outline:none;text-align:center;font-family:monospace}
.setup-input::placeholder{color:rgba(0,0,0,0.3)}
.setup-input:focus{border-color:rgba(0,0,0,0.5);background:rgba(255,255,255,0.25)}
.setup-btn{margin-top:20px;padding:14px 40px;border-radius:30px;border:1.5px solid rgba(0,0,0,0.5);background:transparent;color:rgba(0,0,0,0.8);font-size:15px;cursor:pointer;transition:all .15s}
.setup-btn:active{background:rgba(0,0,0,0.1);transform:scale(0.97)}
.setup-hint{margin-top:16px;font-size:11px;color:rgba(0,0,0,0.3)}

/* Main Screen */
#main-screen{z-index:10}
#orb{width:140px;height:140px;border-radius:50%;border:2px solid rgba(0,0,0,0.6);cursor:pointer;transition:transform .2s}
#orb:active{transform:scale(0.95)}
.breathing{animation:breathe 3s ease-in-out infinite}
.pulsing{animation:pulse .8s ease-in-out infinite}
.waving{animation:wave 1.5s ease-in-out infinite}
@keyframes breathe{0%,100%{transform:scale(1)}50%{transform:scale(1.04)}}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.1)}}
@keyframes wave{0%,100%{transform:scale(1);border-color:rgba(0,0,0,0.6)}50%{transform:scale(1.06);border-color:rgba(0,0,0,0.9)}}

#label{font-size:13px;letter-spacing:2px;text-transform:uppercase;color:rgba(0,0,0,0.45);margin-top:24px}
#reply{position:absolute;bottom:60px;left:20px;right:20px;text-align:center;font-size:15px;color:rgba(255,255,255,0.85);line-height:1.6;opacity:0;transition:opacity .5s;max-height:120px;overflow-y:auto}
#reply.show{opacity:1}
#conn{position:absolute;top:14px;right:14px;width:8px;height:8px;border-radius:50%;background:rgba(0,0,0,0.15)}
#conn.on{background:#222}
#settings-btn{position:absolute;top:10px;left:14px;background:none;border:none;color:rgba(0,0,0,0.25);font-size:20px;cursor:pointer;padding:4px}
#settings-btn:hover{color:rgba(0,0,0,0.5)}
</style>
</head>
<body>

<!-- PIN Screen -->
<div id="pin-screen" class="screen">
  <div class="pin-error" id="pin-error"></div>
  <div class="pin-dots" id="pin-dots">
    <div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div><div class="pin-dot"></div>
  </div>
  <div class="keypad" id="keypad">
    <div class="key" data-n="1">1</div><div class="key" data-n="2">2</div><div class="key" data-n="3">3</div>
    <div class="key" data-n="4">4</div><div class="key" data-n="5">5</div><div class="key" data-n="6">6</div>
    <div class="key" data-n="7">7</div><div class="key" data-n="8">8</div><div class="key" data-n="9">9</div>
    <div class="key del" data-n="del">DEL</div><div class="key zero" data-n="0">0</div>
  </div>
</div>

<!-- Setup Screen -->
<div id="setup-screen" class="screen hidden">
  <div class="setup-box">
    <h2>Backend Server</h2>
    <p>Enter the WebSocket URL of your Samantha server running at home.</p>
    <input class="setup-input" id="ws-url" type="url" placeholder="ws://192.168.1.x:8765" autocomplete="off" spellcheck="false">
    <br>
    <button class="setup-btn" id="connect-btn">Connect</button>
    <div class="setup-hint" id="setup-status"></div>
  </div>
</div>

<!-- Main Screen -->
<div id="main-screen" class="screen hidden">
  <div id="conn"></div>
  <button id="settings-btn">⚙</button>
  <div id="orb" class="breathing"></div>
  <div id="label">tap to talk</div>
  <div id="reply"></div>
</div>

<script>
const $ = id => document.getElementById(id);
const PIN = '0913';
const LS_KEY = 'samantha_ws_url';

// ── PIN ────────────────────────────────────────────────────
let pinBuf = '';
const dots = $('pin-dots').children;

$('keypad').addEventListener('click', e => {
  const k = e.target.closest('.key');
  if (!k) return;
  const n = k.dataset.n;
  if (n === 'del') { pinBuf = pinBuf.slice(0,-1); }
  else if (pinBuf.length < 4) { pinBuf += n; }
  [...dots].forEach((d,i) => d.classList.toggle('filled', i < pinBuf.length));
  if (pinBuf.length === 4) {
    if (pinBuf === PIN) {
      setTimeout(() => {
        $('pin-screen').classList.add('hidden');
        // If served from backend (not GitHub Pages), auto-connect
        if (!location.hostname.includes('github.io')) {
          startApp(autoWsUrl());
        } else {
          const saved = localStorage.getItem(LS_KEY);
          if (saved) { startApp(saved); }
          else { $('setup-screen').classList.remove('hidden'); }
        }
      }, 200);
    } else {
      $('pin-error').textContent = 'wrong pin';
      pinBuf = '';
      [...dots].forEach(d => d.classList.remove('filled'));
      setTimeout(() => $('pin-error').textContent = '', 1500);
    }
  }
});

// ── Setup ──────────────────────────────────────────────────
// Auto-detect: if served from the backend itself, use same-origin WS
function autoWsUrl() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  return proto + '//' + location.host + '/ws';
}

$('connect-btn').addEventListener('click', () => {
  let url = $('ws-url').value.trim();
  if (!url) return;
  // Normalize: ensure ws:// or wss://
  if (!url.startsWith('ws://') && !url.startsWith('wss://')) {
    url = 'ws://' + url;
  }
  // Add /ws if not present
  if (!url.endsWith('/ws')) {
    url = url.replace(/\/$/, '') + '/ws';
  }
  $('setup-status').textContent = 'connecting...';
  testAndSave(url);
});

function testAndSave(url) {
  const test = new WebSocket(url);
  const timer = setTimeout(() => { test.close(); $('setup-status').textContent = 'timeout — check URL'; }, 5000);
  test.onopen = () => {
    clearTimeout(timer);
    test.close();
    localStorage.setItem(LS_KEY, url);
    $('setup-screen').classList.add('hidden');
    startApp(url);
  };
  test.onerror = () => {
    clearTimeout(timer);
    $('setup-status').textContent = 'failed — check URL and server';
  };
}

// ── Settings gear ──────────────────────────────────────────
$('settings-btn').addEventListener('click', () => {
  $('main-screen').classList.add('hidden');
  $('ws-url').value = localStorage.getItem(LS_KEY) || '';
  $('setup-status').textContent = '';
  $('setup-screen').classList.remove('hidden');
});

// ── Main App ───────────────────────────────────────────────
let ws, state = 'idle';
let audioCtx, recorder, micStream, analyser, micData;
let audioQueue = [], isPlaying = false;
let silenceTimer, hasSpoken, maxTimer;
let replyFadeTimer;
const orb = $('orb'), label = $('label'), reply = $('reply'), conn = $('conn');

function startApp(wsUrl) {
  $('main-screen').classList.remove('hidden');
  connect(wsUrl);
}

function connect(wsUrl) {
  ws = new WebSocket(wsUrl);

  ws.onopen = () => {
    conn.classList.add('on');
    console.log('Connected to', wsUrl);
  };

  ws.onclose = () => {
    conn.classList.remove('on');
    setTimeout(() => connect(wsUrl), 3000);
  };

  ws.onerror = () => console.log('WS error');

  ws.onmessage = (e) => {
    const msg = JSON.parse(e.data);

    if (msg.type === 'status') {
      if (msg.text === 'thinking') { go('thinking'); }
      else if (msg.text === 'speaking') { go('speaking'); }
      else if (msg.text === 'idle') {
        if (state !== 'speaking') go('idle');
      }
    }
    else if (msg.type === 'user_text') {
      label.textContent = '"' + msg.text + '"';
    }
    else if (msg.type === 'audio') {
      showReply(msg.text);
      queuePlay(msg.data);
    }
    else if (msg.type === 'done') {
      showReply(msg.text);
    }
    else if (msg.type === 'error') {
      label.textContent = 'error';
      go('idle');
    }
    else if (msg.type === 'pong') { /* keepalive */ }
  };
}

function go(s) {
  state = s;
  orb.className = '';
  if (s === 'idle')      { orb.classList.add('breathing'); label.textContent = 'tap to talk'; }
  if (s === 'listening') { orb.classList.add('waving');    label.textContent = 'listening'; }
  if (s === 'thinking')  { orb.classList.add('pulsing');   label.textContent = 'thinking'; }
  if (s === 'speaking')  { orb.classList.add('pulsing');   label.textContent = ''; }
}

function showReply(text) {
  clearTimeout(replyFadeTimer);
  reply.textContent = text;
  reply.classList.add('show');
}

function hideReply() {
  replyFadeTimer = setTimeout(() => reply.classList.remove('show'), 5000);
}

// ── Audio playback ─────────────────────────────────────────
// Use an Audio element for iOS compatibility (avoids AudioContext autoplay issues)
let audioEl = null;

function initAudio() {
  if (!audioEl) {
    audioEl = new Audio();
    audioEl.playsInline = true;
    // Unlock audio on first user tap
    document.addEventListener('touchstart', () => {
      if (audioEl) { audioEl.play().catch(()=>{}); audioEl.pause(); }
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
    }, { once: true });
  }
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function queuePlay(b64) {
  audioQueue.push(b64);
  if (!isPlaying) playNext();
}

function playNext() {
  if (!audioQueue.length) {
    isPlaying = false;
    go('idle');
    hideReply();
    return;
  }
  isPlaying = true;
  go('speaking');
  initAudio();

  const b64 = audioQueue.shift();

  // Try Audio element first (better iOS support)
  try {
    const dataUrl = 'data:audio/wav;base64,' + b64;
    audioEl.src = dataUrl;
    audioEl.onended = () => playNext();
    audioEl.onerror = () => {
      console.log('Audio element failed, trying AudioContext');
      playWithContext(b64);
    };
    audioEl.play().catch(() => playWithContext(b64));
  } catch(e) {
    playWithContext(b64);
  }
}

function playWithContext(b64) {
  const raw = atob(b64);
  const arr = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) arr[i] = raw.charCodeAt(i);

  audioCtx.decodeAudioData(arr.buffer.slice(0), buf => {
    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.onended = playNext;
    src.start();
  }, () => playNext());
}

// ── Recording ──────────────────────────────────────────────
async function startRec() {
  initAudio();
  try {
    micStream = await navigator.mediaDevices.getUserMedia({
      audio: { echoCancellation: true, noiseSuppression: true }
    });
  } catch(e) { console.log('mic denied'); return false; }

  const src = audioCtx.createMediaStreamSource(micStream);
  analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  micData = new Uint8Array(analyser.frequencyBinCount);
  src.connect(analyser);
  hasSpoken = false;
  silenceTimer = null;
  detectSilence();

  const chunks = [];
  const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus' : 'audio/webm';
  recorder = new MediaRecorder(micStream, { mimeType: mime });
  recorder.ondataavailable = e => { if (e.data.size) chunks.push(e.data); };
  recorder.start(100);

  maxTimer = setTimeout(finish, 15000);

  async function finish() {
    if (state !== 'listening') return;
    clearTimeout(maxTimer);
    clearTimeout(silenceTimer);
    go('thinking');

    const b64 = await new Promise(resolve => {
      recorder.onstop = async () => {
        micStream.getTracks().forEach(t => t.stop());
        const blob = new Blob(chunks, { type: 'audio/webm' });
        const buf = await blob.arrayBuffer();
        const bytes = new Uint8Array(buf);
        let bin = '';
        for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);
        resolve(btoa(bin));
      };
      recorder.stop();
    });

    if (b64 && ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: 'audio', audio: b64 }));
    } else {
      go('idle');
    }
  }

  window._finish = finish;
  return true;
}

function detectSilence() {
  if (state !== 'listening') return;
  requestAnimationFrame(detectSilence);
  analyser.getByteFrequencyData(micData);
  let sum = 0;
  for (let i = 0; i < micData.length; i++) sum += micData[i];
  const amp = sum / micData.length / 255;
  if (amp > 0.04) { hasSpoken = true; clearTimeout(silenceTimer); silenceTimer = null; }
  else if (hasSpoken && !silenceTimer) {
    silenceTimer = setTimeout(() => window._finish && window._finish(), 1500);
  }
}

// ── Tap handler ────────────────────────────────────────────
orb.addEventListener('click', async () => {
  if (state === 'thinking') return;
  if (state === 'speaking') {
    audioQueue = [];
    isPlaying = false;
    go('idle');
    return;
  }
  if (state === 'listening') {
    if (window._finish) window._finish();
    return;
  }
  reply.classList.remove('show');
  reply.textContent = '';
  audioQueue = [];
  isPlaying = false;
  if (await startRec()) go('listening');
});

// Keepalive
setInterval(() => {
  if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type: 'ping' }));
}, 25000);
</script>
</body>
</html>
